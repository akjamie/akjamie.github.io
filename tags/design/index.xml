<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Design on Jamie&#39;s Blog</title>
    <link>http://akjamie.github.io/tags/design/</link>
    <description>Recent content in Design on Jamie&#39;s Blog</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 23 Jul 2019 19:40:10 +0000</lastBuildDate>
    <atom:link href="http://akjamie.github.io/tags/design/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>微服务中的分布式事务</title>
      <link>http://akjamie.github.io/post/2019-07-24-one-distributed-transaction-user-case/</link>
      <pubDate>Tue, 23 Jul 2019 19:40:10 +0000</pubDate>
      <guid>http://akjamie.github.io/post/2019-07-24-one-distributed-transaction-user-case/</guid>
      <description>&lt;h1 id=&#34;用户场景&#34;&gt;用户场景&lt;/h1&gt;&#xA;&lt;p&gt;在某企业app上做Payment业务，在app端准备好request data， 如debit account number, credit account number, amount, notes, 点击submit。&lt;br&gt;&#xA;业务流程如下:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;用户提交payment 请求&lt;/li&gt;&#xA;&lt;li&gt;server校验用户所在公司的每日转账限额(account level)&lt;/li&gt;&#xA;&lt;li&gt;如果限额可以满足，则发起转账，否则reject请求&lt;br&gt;&#xA;&#xD;&#xA;  &lt;img src=&#34;http://akjamie.github.io/img/2019-07-24-one-distributed-transaction-user-case/overall-business-flow.png&#34; alt=&#34;&#34;&gt;&#xD;&#xA;&#xD;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h1 id=&#34;问题和挑战&#34;&gt;问题和挑战&lt;/h1&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;如何规避重复提交&lt;/li&gt;&#xA;&lt;li&gt;如何避免分布式事务&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h1 id=&#34;解决思路&#34;&gt;解决思路&lt;/h1&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;如何规避重复提交&lt;br&gt;&#xA;采用前端/后端生成UUID(it will be used as payment id), 需要缓存起来便于request进来后的校验， 当然也可以不缓存，只是校验这个ID是否已经存在，如果存在就reject请求。&lt;/li&gt;&#xA;&lt;li&gt;如何避免分布式事务&lt;br&gt;&#xA;本例中，主要的分布式事务check point有3个，&lt;br&gt;&#xA;1)计算limit checking，在此过程中可能有新payment请求过来可能导致limit用尽或超支，这是业务上不能允许的;&lt;br&gt;&#xA;采用乐观锁,把锁控制在payment db里面而不是对entitlement db中的transaction limit进行CRUD，这样会使整个事务处理变得复杂; 且兵并发性能有大幅度提升&lt;br&gt;&#xA;2)payment data 写入transaction history db&lt;br&gt;&#xA;Oracle RAC事务，用spring transaction 注解，@Transactional&lt;br&gt;&#xA;3)update B/E system response - payment status(succ/fail)&lt;br&gt;&#xA;Oracle RAC事务，用spring transaction 注解，@Transactional&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h1 id=&#34;解决方案&#34;&gt;解决方案&lt;/h1&gt;&#xA;&lt;p&gt;一个方案proposal如下,主要针对limit checking部分加锁， payment data写入和status update 单独分开事务控制(主要由于如果B/E执行成功了，而update status failed导致payment数据回滚会导致数据丢失)&lt;br&gt;&#xA;处理流程diagram如下:&lt;br&gt;&#xA;&#xD;&#xA;  &lt;img src=&#34;http://akjamie.github.io/img/2019-07-24-one-distributed-transaction-user-case/solution.jpg&#34; alt=&#34;&#34;&gt;&#xD;&#xA;&#xD;&#xA;&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
