<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Spring on Jamie&#39;s Blog</title>
    <link>http://akjamie.github.io/tags/spring/</link>
    <description>Recent content in Spring on Jamie&#39;s Blog</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 31 Aug 2019 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://akjamie.github.io/tags/spring/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Spring Transaction</title>
      <link>http://akjamie.github.io/post/2019-08-31-spring-global-transaction/</link>
      <pubDate>Sat, 31 Aug 2019 00:00:00 +0000</pubDate>
      <guid>http://akjamie.github.io/post/2019-08-31-spring-global-transaction/</guid>
      <description>&lt;p&gt;先回顾上一篇sprint local transaction的内容，本地事务是用于指定资源，即单一数据源，其主要结构如下：&#xA;&#xD;&#xA;  &lt;img src=&#34;http://akjamie.github.io/img/2019-08-31-spring-global-transaction/spring-txn-local.png&#34; alt=&#34;&#34;&gt;&#xD;&#xA;&#xD;&#xA;&#xA;那么我们来看看spring的global transaction管理，其主要用于多数据源的业务场景中，如mysql + mysql, oracle + mysql + rabbitmq等，但是说到全局事务，我们需要先来谈谈xa。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Spring Transaction</title>
      <link>http://akjamie.github.io/post/2019-08-30-spring-local-transaction/</link>
      <pubDate>Fri, 30 Aug 2019 00:00:00 +0000</pubDate>
      <guid>http://akjamie.github.io/post/2019-08-30-spring-local-transaction/</guid>
      <description>&lt;h1 id=&#34;事务特性和隔离级别&#34;&gt;事务特性和隔离级别&lt;/h1&gt;&#xA;&lt;h2 id=&#34;事务基础&#34;&gt;事务基础&lt;/h2&gt;&#xA;&lt;h3 id=&#34;事务特性&#34;&gt;事务特性&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;- 原子性(Atomicity)&#xA;事务包含的所有操作是一个原子单元，要么全部成功，要么全部失败&#xA;- 一致性（Consistency）&#xA;A给B转钱，A减和B增这两个操作必须保持一致&#xA;- 隔离性（Isolation）&#xA;事务中的数据可见性，不同隔离级别，确保了不同的可见性级别，防止脏读，幻读等&#xA;- 持久性（Durability）&#xA;事务操作结果将被持久化到存储磁盘上&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;事务的隔离级别&#34;&gt;事务的隔离级别&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;- Read Uncommitted，可以读取其它事务未完成的结果&#xA;- Read Committed，在该事务完成后，才能读取该事务的数据更新后的结果&#xA;- Repeatable Read，可以保证在整个事务的过程中，对同一笔数据的读取结果是相同的，不管其他事务是否同时在对同一笔数据进行更新，也不管其他事务对同一笔数 据的更新提交与否&#xA;- Serializable，最严格的事务隔离控制，类似于表级别锁，所有事务操作依次有序执行&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;sql事务测试举例---mysql&#34;&gt;SQL事务测试举例 - mysql&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;查看事务隔离级别, 默认是REPEATABLE-READ&#xA;select @@global.transaction_isolation,@@transaction_isolation; &#xA;&#xA;设置事务隔离级别&#xA;SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;&#xA;level: { REPEATABLE READ | READ COMMITTED | READ UNCOMMITTED | SERIALIZABLE }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;通过设置mysql的session或者全局事务隔离级别，来查看事务执行结果&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
