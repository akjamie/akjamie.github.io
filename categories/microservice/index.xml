<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Microservice on Jamie&#39;s Blog</title>
    <link>http://akjamie.github.io/categories/microservice/</link>
    <description>Recent content in Microservice on Jamie&#39;s Blog</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 08 Jul 2022 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://akjamie.github.io/categories/microservice/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Spring Data &amp; Data Persistent</title>
      <link>http://akjamie.github.io/post/2022-07-08-spring-data-series-01/</link>
      <pubDate>Fri, 08 Jul 2022 00:00:00 +0000</pubDate>
      <guid>http://akjamie.github.io/post/2022-07-08-spring-data-series-01/</guid>
      <description>&lt;h1 id=&#34;what-is-jpa&#34;&gt;What is JPA?&lt;/h1&gt;&#xA;&lt;p&gt;&amp;ldquo;The Java Persistence API is the Java API for the management of persistence and object/relational mapping in Java EE and Java SE environments. It provides an object/relational mapping facility for the Java application developer using a Java domain model to manage a relational database.&amp;rdquo;&lt;br&gt;&#xA;It&amp;rsquo;s quoted from JSR(Java Specification Request) managed by Java Community Process.&lt;/p&gt;&#xA;&lt;p&gt;This is just the definition of what&amp;rsquo;s JPA, let&amp;rsquo;s recall how we persist data before adopting JPA.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Websocket集成</title>
      <link>http://akjamie.github.io/post/2022-07-04-spring-websocket-stomp/</link>
      <pubDate>Mon, 04 Jul 2022 00:00:00 +0000</pubDate>
      <guid>http://akjamie.github.io/post/2022-07-04-spring-websocket-stomp/</guid>
      <description>&lt;h1 id=&#34;background&#34;&gt;Background&lt;/h1&gt;&#xA;&lt;p&gt;最近在做一个类似于快速竞价的功能的技术设计，即在很短的时间内通过一个集中的平台拿到各家的报价，类似于支付宝上的那个车险报价，发送完汽车信息，得到各家保险公司的报价回复，然后可以选择某家性价比高的价格购买汽车保险。在设计的过程很快就想到了用websocket+stomp这种长链接和event-streaming 推送的方式，做了一些技术研究和验证，因此便记录这些零碎的知识便于以后查阅。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Microservice design - practice</title>
      <link>http://akjamie.github.io/post/2021-05-08-microservice-data-sync/</link>
      <pubDate>Sat, 08 May 2021 00:00:00 +0000</pubDate>
      <guid>http://akjamie.github.io/post/2021-05-08-microservice-data-sync/</guid>
      <description>&lt;h1 id=&#34;summary&#34;&gt;Summary&lt;/h1&gt;&#xA;&lt;p&gt;To mark down a batch data sync accross system solution, tested daily sync data volume is around 10w.&lt;br&gt;&#xA;In this solution, adopted the message driven batch processing rather than traditional fixed time schedule batch.&lt;br&gt;&#xA;Also applied the microservice design to eliminate the system dependency and well protect the data/system boundry,which is also aligned with the DEVOPS,,both team could focus on their own domain/services&amp;rsquo; development and maintenance.&lt;/p&gt;&#xA;&lt;h1 id=&#34;techniques-used&#34;&gt;Techniques used&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Springboot + Spring cloud config, constrained by infra, services are running on in hourse VM instances.&lt;/li&gt;&#xA;&lt;li&gt;Quartz, based on java, easy to custom against requirements, also support clustering.&lt;/li&gt;&#xA;&lt;li&gt;Oracle database&lt;/li&gt;&#xA;&lt;li&gt;JWT is adopted for system to system authentication and authorization.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;key-components&#34;&gt;Key Components&lt;/h1&gt;&#xA;&lt;h2 id=&#34;scheduling-platform&#34;&gt;Scheduling Platform&lt;/h2&gt;&#xA;&lt;p&gt;The platform is implemented using Springboot + Quartz + JDBC, store the all the Quartz related configs in database, it support clustering and easy to build support portal to server better user experience on operation angle.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Kubernates - Practice</title>
      <link>http://akjamie.github.io/post/2020-11-29-run-application-on-k8s/</link>
      <pubDate>Sun, 29 Nov 2020 00:00:00 +0000</pubDate>
      <guid>http://akjamie.github.io/post/2020-11-29-run-application-on-k8s/</guid>
      <description>&lt;p&gt;this page shows how to run a spring boot application on local K8S environment.&lt;/p&gt;&#xA;&lt;h1 id=&#34;objectives&#34;&gt;Objectives&lt;/h1&gt;&#xA;&lt;p&gt;1.create spring boot application and build a docker image&lt;br&gt;&#xA;2.create local persistent volume to share the files from host&lt;br&gt;&#xA;3.create deployment and service to run this application and expose for external access.&lt;/p&gt;&#xA;&lt;h1 id=&#34;before-you-begin&#34;&gt;Before you begin&lt;/h1&gt;&#xA;&lt;p&gt;install docker desktop in local and enable local k8s cluster, more details please refer to docker official guide or k8s local&#xA;cluster setup &lt;a href=&#34;https://kubernetes.io/docs/tasks/tools/&#34;&gt;guide&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Spring Transaction</title>
      <link>http://akjamie.github.io/post/2019-08-31-spring-global-transaction/</link>
      <pubDate>Sat, 31 Aug 2019 00:00:00 +0000</pubDate>
      <guid>http://akjamie.github.io/post/2019-08-31-spring-global-transaction/</guid>
      <description>&lt;p&gt;先回顾上一篇sprint local transaction的内容，本地事务是用于指定资源，即单一数据源，其主要结构如下：&#xA;&#xD;&#xA;  &lt;img src=&#34;http://akjamie.github.io/img/2019-08-31-spring-global-transaction/spring-txn-local.png&#34; alt=&#34;&#34;&gt;&#xD;&#xA;&#xD;&#xA;&#xA;那么我们来看看spring的global transaction管理，其主要用于多数据源的业务场景中，如mysql + mysql, oracle + mysql + rabbitmq等，但是说到全局事务，我们需要先来谈谈xa。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Spring Transaction</title>
      <link>http://akjamie.github.io/post/2019-08-30-spring-local-transaction/</link>
      <pubDate>Fri, 30 Aug 2019 00:00:00 +0000</pubDate>
      <guid>http://akjamie.github.io/post/2019-08-30-spring-local-transaction/</guid>
      <description>&lt;h1 id=&#34;事务特性和隔离级别&#34;&gt;事务特性和隔离级别&lt;/h1&gt;&#xA;&lt;h2 id=&#34;事务基础&#34;&gt;事务基础&lt;/h2&gt;&#xA;&lt;h3 id=&#34;事务特性&#34;&gt;事务特性&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;- 原子性(Atomicity)&#xA;事务包含的所有操作是一个原子单元，要么全部成功，要么全部失败&#xA;- 一致性（Consistency）&#xA;A给B转钱，A减和B增这两个操作必须保持一致&#xA;- 隔离性（Isolation）&#xA;事务中的数据可见性，不同隔离级别，确保了不同的可见性级别，防止脏读，幻读等&#xA;- 持久性（Durability）&#xA;事务操作结果将被持久化到存储磁盘上&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;事务的隔离级别&#34;&gt;事务的隔离级别&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;- Read Uncommitted，可以读取其它事务未完成的结果&#xA;- Read Committed，在该事务完成后，才能读取该事务的数据更新后的结果&#xA;- Repeatable Read，可以保证在整个事务的过程中，对同一笔数据的读取结果是相同的，不管其他事务是否同时在对同一笔数据进行更新，也不管其他事务对同一笔数 据的更新提交与否&#xA;- Serializable，最严格的事务隔离控制，类似于表级别锁，所有事务操作依次有序执行&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;sql事务测试举例---mysql&#34;&gt;SQL事务测试举例 - mysql&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;查看事务隔离级别, 默认是REPEATABLE-READ&#xA;select @@global.transaction_isolation,@@transaction_isolation; &#xA;&#xA;设置事务隔离级别&#xA;SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;&#xA;level: { REPEATABLE READ | READ COMMITTED | READ UNCOMMITTED | SERIALIZABLE }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;通过设置mysql的session或者全局事务隔离级别，来查看事务执行结果&lt;/p&gt;</description>
    </item>
    <item>
      <title>微服务中的分布式事务</title>
      <link>http://akjamie.github.io/post/2019-07-24-one-distributed-transaction-user-case/</link>
      <pubDate>Tue, 23 Jul 2019 19:40:10 +0000</pubDate>
      <guid>http://akjamie.github.io/post/2019-07-24-one-distributed-transaction-user-case/</guid>
      <description>&lt;h1 id=&#34;用户场景&#34;&gt;用户场景&lt;/h1&gt;&#xA;&lt;p&gt;在某企业app上做Payment业务，在app端准备好request data， 如debit account number, credit account number, amount, notes, 点击submit。&lt;br&gt;&#xA;业务流程如下:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;用户提交payment 请求&lt;/li&gt;&#xA;&lt;li&gt;server校验用户所在公司的每日转账限额(account level)&lt;/li&gt;&#xA;&lt;li&gt;如果限额可以满足，则发起转账，否则reject请求&lt;br&gt;&#xA;&#xD;&#xA;  &lt;img src=&#34;http://akjamie.github.io/img/2019-07-24-one-distributed-transaction-user-case/overall-business-flow.png&#34; alt=&#34;&#34;&gt;&#xD;&#xA;&#xD;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h1 id=&#34;问题和挑战&#34;&gt;问题和挑战&lt;/h1&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;如何规避重复提交&lt;/li&gt;&#xA;&lt;li&gt;如何避免分布式事务&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h1 id=&#34;解决思路&#34;&gt;解决思路&lt;/h1&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;如何规避重复提交&lt;br&gt;&#xA;采用前端/后端生成UUID(it will be used as payment id), 需要缓存起来便于request进来后的校验， 当然也可以不缓存，只是校验这个ID是否已经存在，如果存在就reject请求。&lt;/li&gt;&#xA;&lt;li&gt;如何避免分布式事务&lt;br&gt;&#xA;本例中，主要的分布式事务check point有3个，&lt;br&gt;&#xA;1)计算limit checking，在此过程中可能有新payment请求过来可能导致limit用尽或超支，这是业务上不能允许的;&lt;br&gt;&#xA;采用乐观锁,把锁控制在payment db里面而不是对entitlement db中的transaction limit进行CRUD，这样会使整个事务处理变得复杂; 且兵并发性能有大幅度提升&lt;br&gt;&#xA;2)payment data 写入transaction history db&lt;br&gt;&#xA;Oracle RAC事务，用spring transaction 注解，@Transactional&lt;br&gt;&#xA;3)update B/E system response - payment status(succ/fail)&lt;br&gt;&#xA;Oracle RAC事务，用spring transaction 注解，@Transactional&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h1 id=&#34;解决方案&#34;&gt;解决方案&lt;/h1&gt;&#xA;&lt;p&gt;一个方案proposal如下,主要针对limit checking部分加锁， payment data写入和status update 单独分开事务控制(主要由于如果B/E执行成功了，而update status failed导致payment数据回滚会导致数据丢失)&lt;br&gt;&#xA;处理流程diagram如下:&lt;br&gt;&#xA;&#xD;&#xA;  &lt;img src=&#34;http://akjamie.github.io/img/2019-07-24-one-distributed-transaction-user-case/solution.jpg&#34; alt=&#34;&#34;&gt;&#xD;&#xA;&#xD;&#xA;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Spring batch - single process &amp; remote partitioning(multi instances)</title>
      <link>http://akjamie.github.io/post/2019-07-21-spring-batch-single-process-remote-partitioning/</link>
      <pubDate>Tue, 23 Jul 2019 13:36:10 +0000</pubDate>
      <guid>http://akjamie.github.io/post/2019-07-21-spring-batch-single-process-remote-partitioning/</guid>
      <description>&lt;p&gt;Spring batch是轻量级，全面的批处理框架，旨在开发对企业系统日常运营至关重要的强大批处理应用程序。&lt;/p&gt;&#xA;&lt;p&gt;Spring Batch负责大量记录，包括日志记录/跟踪，事务管理，作业处理统计，作业重启，跳过和资源管理。 它还提供更高级的技术服务和功能，通过优化和分区技术实现极高容量和高性能的批处理作业。 简单和复杂的大批量批处理作业可以高度可扩展的方式利用框架来处理大量信息。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Spring Cloud Series</title>
      <link>http://akjamie.github.io/post/2019-07-15-spring-cloud-demo-overview/</link>
      <pubDate>Tue, 23 Jul 2019 13:36:10 +0000</pubDate>
      <guid>http://akjamie.github.io/post/2019-07-15-spring-cloud-demo-overview/</guid>
      <description>&lt;h1 id=&#34;demo的介绍&#34;&gt;Demo的介绍&lt;/h1&gt;&#xA;&lt;p&gt;本文主要通过一个小demo，来综合运用spring cloud系列技术，demo中主要包含如下模块/组建：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Authorization service, 基于Spring Security Oauth2 + Spring Cloud Oauth2,提供集中授权服务,如Token 生成,校验等&lt;/li&gt;&#xA;&lt;li&gt;API gateway, edge service, 提供统一的对外访问接口，集成了oauth2 安全校验，Netflix Hystrix服务降级，依赖隔离，断路保护功能&lt;/li&gt;&#xA;&lt;li&gt;Service registry,基于Netflix Eureka的注册中心提供服务注册和服务发现功能&lt;/li&gt;&#xA;&lt;li&gt;Config service, 采用了 Spring cloud config + Spring Cloud Bus提供简单的配置中心&lt;/li&gt;&#xA;&lt;li&gt;Catalog service, 示例服务，模拟一个简单的商品服务目录，仅一维结构&lt;/li&gt;&#xA;&lt;li&gt;Inventory service, 示例服务, 模拟简单的商品库存服务&lt;/li&gt;&#xA;&lt;li&gt;Hystrix dashboard, 聚合hystrix的metrics监控展示&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h1 id=&#34;整体架构&#34;&gt;整体架构&lt;/h1&gt;&#xA;&lt;p&gt;&#xD;&#xA;  &lt;img src=&#34;http://akjamie.github.io/img/2019-07-15-spring-cloud-demo-overview/architecture.png&#34; alt=&#34;&#34;&gt;&#xD;&#xA;&#xD;&#xA;&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
